1Ô∏è‚É£ Node.js

Definition:
Node.js is a JavaScript runtime built on Chrome‚Äôs V8 engine that allows JS to run on the server-side.

Type: Runtime environment, not a framework.

Why used:

Server-side scripting with JS.

Handles high concurrency with non-blocking, event-driven architecture.

Key Features:

Asynchronous I/O

Single-threaded, non-blocking

NPM ecosystem for libraries

Interview Tip: Difference between Node.js vs traditional server (e.g., PHP, Java)

2Ô∏è‚É£ Express.js

Definition:
Minimal, fast Node.js web framework for building APIs and web apps.

Type: Framework

Why used:

Simplifies server creation.

Routing, middleware, request handling made easier.

Example Libraries Used With Express:

body-parser ‚Üí parse JSON

cors ‚Üí Cross-Origin Resource Sharing

jsonwebtoken ‚Üí JWT authentication

Difference:

Express	Node.js
Framework	Runtime
Simplifies routing & middleware	Raw server & HTTP module
Easier API creation	You must write raw request/response logic
3Ô∏è‚É£ React.js

Definition: Frontend library for building UI components.

Type: Library (not full framework)

Why used:

Component-based architecture

Virtual DOM for efficient rendering

Single-page applications (SPA)

Key Features:

JSX

Hooks (useState, useEffect, useRef, useMemo, etc.)

Context API for global state

React vs React Native:

React	React Native
Web applications	Mobile applications
Renders HTML	Renders native UI components
4Ô∏è‚É£ MongoDB

Definition: NoSQL database storing data as JSON-like documents.

Type: Database (Document-oriented)

Why used:

Flexible schema ‚Üí easy to scale

High performance for large data

Works well with Node.js

Key Terms:

Collection ‚Üí like SQL table

Document ‚Üí like SQL row (JSON object)

Transaction/Session ‚Üí atomic operations across multiple documents

Difference: MongoDB vs SQL

MongoDB	SQL (MySQL/Postgres)
Schema-less	Fixed schema
JSON documents	Tables & rows
Horizontal scaling	Vertical scaling
5Ô∏è‚É£ Mongoose

Definition: Node.js ODM (Object Data Modeling) library for MongoDB.

Type: Library

Why used:

Simplifies MongoDB queries

Schema definition & validation

Middleware/hooks support

Example:

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String
});


Mongoose vs MongoDB Native Driver:

Mongoose	Native MongoDB Driver
Schema-based	Flexible JSON
Validation & middleware	Manual validation
Easier for models & relations	Direct queries
6Ô∏è‚É£ REST API & HTTP Methods

Definition: REST = Representational State Transfer, architectural style for APIs.

HTTP Methods:

GET ‚Üí fetch data

POST ‚Üí create data

PUT ‚Üí update/replace data

PATCH ‚Üí update part of data

DELETE ‚Üí remove data

Why used:

Stateless, scalable, and standardized API design

REST vs GraphQL:

REST	GraphQL
Multiple endpoints	Single endpoint
Over-fetching possible	Fetch exactly what you need
Standard HTTP verbs	Queries & Mutations
7Ô∏è‚É£ Authentication & Authorization

Authentication: Verify who the user is (login).

Authorization: Verify what user can access (roles & permissions).

JWT (JSON Web Token):

Token-based auth for stateless sessions

Encodes payload + signature

Role-based Access Control (RBAC):

Users can have roles: admin, user

Middleware checks permissions

8Ô∏è‚É£ Frontend Concepts

useState: Local component state.

useEffect: Side-effects like API calls.

useRef: Access DOM nodes or store mutable values.

useMemo / useCallback: Optimize performance by memoizing results/functions.

Debounce / Throttle: Optimize frequent events (scroll, input)

9Ô∏è‚É£ Node.js & Express Middleware

Definition: Functions executed before request reaches the final route.

Types:

Application-level ‚Üí app.use()

Router-level ‚Üí router.use()

Error-handling middleware ‚Üí 4 params (err, req, res, next)

Why used:

Authentication, logging, parsing, error handling

üîü Other Libraries/Tools
Tool/Library	Type	Purpose
bcryptjs	Library	Hash passwords
nodemailer	Library	Send emails
multer	Library	File upload
dotenv	Library	Manage env variables
axios/fetch	Library	HTTP requests from frontend
11Ô∏è‚É£ Full-Stack Architecture Terms

MVC (Model-View-Controller):

Model ‚Üí Data (Mongoose schema)

View ‚Üí Frontend (React component)

Controller ‚Üí Route logic

SPA (Single Page Application):

Single HTML page, dynamic content via JS

React/Angular/Vue

SSR (Server Side Rendering):

Render pages on server ‚Üí better SEO

Next.js is popular for React SSR

12Ô∏è‚É£ Database & Index Terms

Index: Speeds up queries

Aggregation: Advanced queries (group, filter, sort, sum)

Transactions & Session: Atomic multi-document operations



Difference Between Authentication and Authorization
üîπ Definition

Authentication means verifying the identity of a user ‚Äî checking who the user is.

Authorization means checking user permissions ‚Äî what the user is allowed to do.

üîπ Explanation (Simple for Freshers)
Authentication

This step happens first.

The system checks if the user is real.

Example:

Entering email + password

OTP verification

Logging in with Google

Authorization

This step happens after authentication.

Once the system knows who you are, it checks what actions you can perform.

Example:

Admin can delete a user
Normal user cannot delete another user
Premium user can access paid content

üî• Main Difference (Short Table)
Authentication	Authorization
Checks identity	Checks permissions
Happens first	Happens after authentication
Login/OTP/password	Roles, access control
Same for all users	Different for each user
üîπ Pros & Cons
‚úî Authentication Pros

Increases security

Protects user data

Simple to implement (password login)

‚ùå Authentication Cons

Password leaks can cause risk

Extra steps like OTP can slow login

‚úî Authorization Pros

Ensures correct access control

Protects sensitive actions (like admin features)

‚ùå Authorization Cons

Complex role management in big systems

Mistakes can cause data leakage or restriction

üéØ Two Follow-up Questions (with short fresher answers)
1. Why do we need both authentication and authorization?

Because authentication verifies who the user is, and authorization decides what they can do. Both are required for secure systems.

2. Can a user be authorized without authentication?

No.
The system must first know who the user is before giving any permissions.
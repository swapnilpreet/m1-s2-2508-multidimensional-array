
Step-by-Step Explanation
    1. Front-End Development Breakdown
        Front-end development deals with how a website looks and feels. A front-end developer uses HTML to structure the content, CSS to style it, and JavaScript to add interactivity.

        Example:
        <!DOCTYPE html>
        <html>
        <head>
            <title>My Website</title>
            <style>
                body { background-color: lightblue; }
                h1 { color: darkblue; text-align: center; }
            </style>
        </head>
        <body>
            <h1>Welcome to My Website</h1>
            <p>This is a sample paragraph.</p>
            <button onclick="alert('Hello!')">Click Me</button>
            <script>
                console.log('Page loaded successfully!');
            </script>
        </body>
        </html>
        In this example, the HTML provides the structure (a heading, paragraph, and button), the CSS adds styling, and JavaScript adds interactivity (an alert on button click).

    2. Back-End Development Breakdown

        The back-end focuses on how a website functions behind the scenes. A back-end developer manages databases, server logic, and APIs. For example, when a user fills out a form, the back-end processes the data and stores it in a database.

        Example of a simple Node.js server:
        const http = require('http');

        // Create a server
        http.createServer((req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        res.end('Hello World!\n');
        }).listen(8080);

        console.log('Server running at http://localhost:8080/');
        In this example, a simple Node.js server listens on port 8080 and responds with "Hello World!" to any request.

    3. The Client-Server Relationship in Action
        When you open a website:

        Client (Browser): The browser sends a request to the server (e.g., "I want the homepage of example.com").
        Server: The server processes the request and sends back the HTML, CSS, and JavaScript files.
        Client: The browser receives the files and renders the webpage for the user to see and interact with.
        Example:

        You visit www.example.com.
        Your browser (client) sends a request to the web server at example.com.
        The server responds with the HTML, CSS, and JavaScript files that define the webpage.
        The browser renders and displays the webpage.

        Examples

        Example 1: Client Request and Server Response
        Client (browser) sends a request:

        GET /index.html HTTP/1.1
        Host: www.example.com
        Server responds:

        HTTP/1.1 200 OK
        Content-Type: text/html
        With the content of the index.html file.

        Example 2: Front-End and Back-End Interaction
        Front-End: User fills out a form (input data).

        <form action="/submit" method="POST">
            <input type="text" name="username" />
            <button type="submit">Submit</button>
        </form>
        Back-End: Server processes the form data.

        app.post('/submit', (req, res) => {
            let username = req.body.username;
            res.send(`Hello, ${username}`);
        });

        Practice Exercises
        Front-End Task:
        Create a simple webpage with a heading, paragraph, and a button. Use CSS to style the page and JavaScript to show an alert when the button is clicked.
        Summary
        In this lesson, we've introduced the concepts of web development and explored the roles of front-end and back-end development. We've learned that the front-end handles what users see and interact with, while the back-end manages server-side logic, databases, and the communication between the client and server. We also covered how clients (web browsers) communicate with servers via HTTP, forming the backbone of how websites are delivered.

Key Takeaways:
    Front-End: Focuses on user interfaces, built with HTML, CSS, and JavaScript.
    Back-End: Manages server logic, databases, and APIs.
    Client-Server Communication: Based on the request-response cycle over HTTP.
    Additional Resources
    Introduction to Web Development - Mozilla Developer Network (MDN)
    HTML Introduction: Structure of an HTML Document
    Introduction
    HTML (HyperText Markup Language) is the foundational language used to create web pages. It provides the structure and content of a webpage, defining everything from text, images, and links to more complex media like forms and videos. Every HTML document follows a basic structure that web browsers interpret and display.

    A well-structured HTML document ensures that your web pages are properly rendered across different browsers and devices, providing a better user experience. This lesson covers the essential building blocks of an HTML document, including the main tags and their purposes.

Key Concepts and Definitions
    1. HTML Document
        An HTML document is a text file that contains HTML code, which is read and rendered by web browsers to display content. Every HTML document starts with a declaration and follows a specific structure, from defining the type of document to organizing the content into various sections.

    2. HTML Tags
         HTML tags are the building blocks of an HTML document. Tags are enclosed in angle brackets and usually come in pairs: an opening tag and a closing tag. For example, the <p> tag creates a paragraph, and its closing tag is </p>.

    3. HTML Elements
         An HTML element consists of an opening tag, content, and a closing tag. For example:
        <p>This is a paragraph.</p>


    4. Attributes
        Attributes provide additional information about an HTML element. They are written inside the opening tag and usually come in key-value pairs. For example:
        <img src="image.jpg" alt="A beautiful image">

Step-by-Step Explanation

The structure of an HTML document follows a well-defined order. Below is a breakdown of each part.

    1. The <!DOCTYPE> Declaration
        The <!DOCTYPE> declaration tells the web browser what version of HTML the document is using. It must appear at the very top of any HTML document and ensures that the browser interprets the HTML code correctly.

        Example:

        <!DOCTYPE html>
        This declares that the document is using HTML5, the latest version of HTML.

    2. The <html> Element
        The <html> element is the root element of an HTML document. It wraps all the content of the webpage and tells the browser that everything within it is HTML.

        Example:

        <html>
            <!-- All other HTML content goes here -->
        </html>
    3. The <head> Element
        The <head> section contains metadata about the document, such as the title, links to external stylesheets, scripts, and character encoding. The contents of the <head> are not displayed on the web page itself but are important for defining how the page is processed.

    Key Elements Inside <head>:

        <meta charset="UTF-8">: Declares the character encoding, ensuring that text is displayed correctly.
        <title>: Defines the title of the document that appears in the browser tab.
        <link>: Links external resources like CSS stylesheets.
        <script>: Can be used to link external JavaScript files.
        Example:

        <head>
            <meta charset="UTF-8">
            <title>My First Web Page</title>
        </head>

    4. The <title> Element
        The <title> element defines the title of the web page that appears in the browser tab. It's an important part of the document, as search engines and users often use it to identify the content of a web page.

        Example:
        <title>Introduction to HTML</title>

    5. The <body> Element
        The <body> element contains all the visible content of the web page—text, images, videos, links, and other elements that users interact with. Anything between the opening <body> tag and closing </body> tag is rendered on the screen.

        Example:
            <body>
                <h1>Welcome to My Web Page</h1>
                <p>This is a paragraph of text on my page.</p>
            </body>
            Full HTML Document Example
            Here's a simple example of a complete HTML document:
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Introduction to HTML</title>
            </head>
            <body>
                <h1>Welcome to My First Web Page</h1>
                <p>This is a simple HTML document.</p>
                <p>HTML provides the structure for web pages, defining elements like headings, paragraphs, images, and links.</p>
            </body>
            </html>

        Breakdown:
            <!DOCTYPE html>: Declares HTML5 as the document type.
            <html lang="en">: The root element that contains all the content of the page and declares the language (English).
            <meta charset="UTF-8">: Ensures that the text is correctly encoded.
            <title>: Sets the title of the page.
            <body>: Contains the visible content, including headings and paragraphs.


Semantic HTML:

    What is Semantic HTML?
        Semantic HTML refers to using HTML tags that clearly describe the content’s purpose and structure, making it more understandable for both developers and browsers. It improves accessibility, SEO (Search Engine Optimization), and makes code more readable.

    Common Semantic Tags

        <header>: Defines the header of a webpage or section, usually containing navigation links, logos, or headings.
        <footer>: Defines the footer of a webpage or section, often containing copyright information, links, or contact info.
        <nav>: Represents a section of the page containing navigation links.
        <section>: Represents a generic section of a document, typically with a thematic grouping of content.
        <article>: Represents independent, self-contained content, such as blog posts, news articles, or forum entries.

CSS Selectors:
    CSS selectors define which HTML elements the styling rules apply to. There are different types of selectors, each used to target specific elements or groups of elements.

    1. Element Selector
        The element selector targets all instances of a specified HTML element. For example, using p will select all <p> elements (paragraphs) in the document.

        Example:
        p {
        color: green;
        }
        This will make all paragraphs on the webpage green.

    2. Class Selector (.class)
        Class selectors target elements that have a specific class attribute. Class names in CSS are preceded by a dot (.).

        Example:
        HTML:

        <p class="highlight">This is highlighted text.</p>
        <p>This is normal text.</p>
        CSS:

        .highlight {
        background-color: yellow;
        }
        In this example, only the paragraph with the class="highlight" will have a yellow background.

    3. ID Selector (#id)
        ID selectors target a single element with a specific id attribute. In CSS, ID selectors are preceded by a hash symbol (#). IDs should be unique and used only once per page.

        Example:
        HTML:

        <h1 id="main-title">Main Title</h1>
        CSS:

        #main-title {
        font-size: 36px;
        color: darkred;
        }
        The ID selector #main-title applies the styling to the element with id="main-title".

    4. Universal Selector (``)
        The universal selector (*) selects all elements on the page. It is commonly used to reset or apply global styles.

        Example:
        * {
        margin: 0;
        padding: 0;
        }
        This rule removes all default margins and padding from every element on the page.
    
When to Use Each Method:

    Inline styles:          For quick, one-time style changes.
    Internal styles:        For styling a single HTML page.
    External stylesheets:   For larger projects and consistent styling across multiple pages.

1. Attribute Selectors:
    What are Attribute Selectors?
        Attribute selectors allow you to target HTML elements based on the presence, value, or partial value of their attributes. They are especially useful when you want to apply styles to elements based on specific attributes, such as href, type, or alt.

        Types of Attribute Selectors:
            [attribute]: Targets elements that have a specific attribute.
            [attribute="value"]: Targets elements with a specific attribute and value.
            [attribute^="value"]: Targets elements where the attribute value begins with a specific string.
            [attribute$="value"]: Targets elements where the attribute value ends with a specific string.
            [attribute="value"]**: Targets elements where the attribute value contains a specific string.

2. Pseudo-Classes:
    What are Pseudo-Classes?
        Pseudo-classes are used to define the state of an element and apply styles based on user interaction or other conditions. Common pseudo-classes include :hover, :active, :focus, and :nth-child. They allow you to style elements dynamically, based on user behavior.

    Commonly Used Pseudo-Classes
        :hover: Applies styles when the user hovers over an element with the mouse.
        :active: Applies styles when the user clicks on an element.
        :focus: Applies styles when an element, like an input field, is focused (e.g., when the user clicks on or tabs into it).

Combinators and Specificity in CSS:
    CSS Combinators:
        Combinators are special selectors that allow you to target elements based on their relationships with other elements in the document. They refine how elements are selected and styled by focusing on parent-child, sibling, and ancestor relationships.

        1.1. Descendant Combinator (Space )
            The descendant combinator selects elements that are nested inside another element, regardless of how deeply they are nested. It selects all descendants of the parent, not just direct children.

            Syntax:
            parent descendant {
            /* styles */
            }
            Example:
            div p {
            color: red;
            }

    Child Combinator (>)
        The child combinator selects only the direct children of an element.

        Syntax:
        parent > child {
        /* styles */
        }
        Example:
        div > p {
        color: blue;
        }
        In this example, only the direct child <p> inside the <div> will be blue. The <p> inside the <section> will not be affected.

    Adjacent Sibling Combinator (+)
        The adjacent sibling combinator selects an element that immediately follows another element. Both elements must share the same parent.
        Syntax:
        element1 + element2 {
        /* styles */
        }
        Example:
        h1 + p {
        color: green;
        }
    General Sibling Combinator (~)
        The general sibling combinator selects all elements that are siblings of another element, regardless of their position in relation to that element.

        Syntax:
        element1 ~ element2 {
        /* styles */
        }
        Example:
        h1 ~ p {
        color: purple;
        }

CSS Specificity:
    Specificity determines which CSS rule is applied to an element when multiple rules target the same element. It is calculated based on the types of selectors used. The higher the specificity, the more weight the rule has.

    Specificity Weight Calculation
        Inline styles (e.g., style="color: blue;") have the highest specificity. (1,0,0,0)
        ID selectors (e.g., #id) have a high specificity. (0,1,0,0)
        Class selectors, attribute selectors, and pseudo-classes (e.g., .class, [attribute], :hover) have medium specificity. (0,0,1,0)
        Element selectors and pseudo-elements (e.g., div, p, :before, :after) have the lowest specificity. (0,0,0,1)
        Specificity is calculated by adding the weights of the selectors in a rule. The rule with the highest specificity is applied.

    Example of Specificity:
        CSS:
        /* Element selector */
        p {
        color: black;
        }
        /* Class selector */
        .special {
        color: blue;
        }

        /* ID selector */
        #unique {
        color: red;
        }
        HTML:
        <p>This paragraph will be black.</p>
        <p class="special">This paragraph will be blue.</p>
        <p id="unique">This paragraph will be red.</p>
        <p id="unique" class="special">This paragraph will be red because ID selectors have higher specificity.</p>

    How Specificity is Calculated:
        p has a specificity of (0,0,0,1).
        .special has a specificity of (0,0,1,0).
        #unique has a specificity of (0,1,0,0).
        Since ID selectors have higher specificity than class selectors, the rule targeting #unique will take precedence over .special, even if both are applied to the same element.


CSS Box Model:
    The CSS Box Model defines how the dimensions and spacing of an element are calculated. Every HTML element is considered a box, and the box model is used to determine the size and spacing of elements on the page. The box model consists of the following components:

        Content: The area where the actual content (e.g., text or image) is displayed.
        Padding: The space between the content and the border.
        Border: A border around the padding and content.
        Margin: The space outside the border, separating the element from others.

        Structure of the CSS Box Model:
            element {
            width: 200px;
            padding: 10px;
            border: 5px solid black;
            margin: 20px;
            }
        This results in the following total width:
            Width = 200px (content)
            Padding = 10px (left and right) = 20px total
            Border = 5px (left and right) = 10px total
            Margin = 20px (left and right) = 40px total
            Total width = 200px + 20px (padding) + 10px (border) + 40px (margin) = 270px
        
Display Properties:
    block
        Elements with display: block take up the full width available, forcing a line break before and after the element. Examples of block-level elements include <div>, <p>, and <h1>.

    inline
        Elements with display: inline only take up as much space as their content requires, and do not force line breaks. Examples include <span>, <a>, and <img>.

    inline-block
        Elements with display: inline-block behave like inline elements (sitting within a line) but can have width and height properties applied, like block elements.
    
    none
        Elements with display: none are completely removed from the document flow, meaning they do not take up any space on the page and are not visible.
    

Positioning Elements:
    CSS provides several ways to position elements on a page, controlling their exact placement in relation to the normal document flow or other elements.

    Static Positioning (Default):
        position: static is the default positioning. Elements are positioned according to the normal flow of the document and are not affected by top, right, bottom, or left properties.
    
    Relative Positioning:
        position: relative positions an element relative to its normal position in the document flow. The element can be moved using the top, right, bottom, and left properties, but it still occupies its original space.

    Absolute Positioning:
        position: absolute removes the element from the normal document flow and positions it relative to its nearest positioned ancestor (i.e., the closest parent element with position: relative, absolute, fixed, or sticky). If there is no such ancestor, the element is positioned relative to the <html> element.
    
    Fixed Positioning
        position: fixed positions the element relative to the browser window, meaning it stays in the same position even when the page is scrolled. It is removed from the document flow.

    Sticky Positioning:
        position: 
             sticky is a hybrid of relative and fixed positioning. The element is positioned relative to the document flow until it reaches a specified position (using top, right, bottom, or left), after which it becomes fixed and remains "stuck" in place during scrolling.
    